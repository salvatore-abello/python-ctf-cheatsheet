# Internals

### random and _random

The random library uses the mt19937 PRNG
```py
# random
import random
from _sha512 import sha512


def random_seed_func(s: bytes) -> int:
    return int.from_bytes(s + sha512(s).digest(), "big")

def test_random_seed(t):
    random.seed(t)
    return random.getrandbits(32)

n1 = b"abobus_abobus_abobus_abobus_abobus_abobus"

res1 = test_random_seed(n1)
res2 = test_random_seed(random_seed_func(n1))

print(res1, res2)

assert res1 == res2
```

```py
# _random
import _random

hshval = b"abobus_abobus_abobus_abobus_abobus_abobus"

r1 = _random.Random(hshval)
r2 = _random.Random(hash(hshval))

# This works 50% of the time
assert r1.getrandbits(32) == r2.getrandbits(32)
```

### Python Hash function

```py
# Hash behavior changes based on the type passed to it

# Integers
import random
n =  random.getrandbits(128)

hash(n) == hash(n % 0x2000000000000000)
assert hash(n) == hash(n % 0xfffffffffffffff8)

# Bytes/strings

hash(b"abobus") # Seems random
```

Hash internally uses SipHash-2-4 with a random seed, called `_Py_HashSecret`, it's possible to extract this value using this script:

```py
from ctypes import (
    c_size_t,
    c_ubyte,
    c_uint64,
    pythonapi,
    Structure,
    Union,
)


class FNV(Structure):
    _fields_ = [
        ('prefix', c_size_t),
        ('suffix', c_size_t)
    ]


class SIPHASH(Structure):
    _fields_ = [
        ('k0', c_uint64),
        ('k1', c_uint64),
    ]


class DJBX33A(Structure):
    _fields_ = [
        ('padding', c_ubyte * 16),
        ('suffix', c_size_t),
    ]


class EXPAT(Structure):
    _fields_ = [
        ('padding', c_ubyte * 16),
        ('hashsalt', c_size_t),
    ]


class _Py_HashSecret_t(Union):
    _fields_ = [
        ('uc', c_ubyte * 24),
        ('fnv', FNV),
        ('siphash', SIPHASH),
        ('djbx33a', DJBX33A),
        ('expat', EXPAT),
    ]


hashsecret = _Py_HashSecret_t.in_dll(pythonapi, '_Py_HashSecret')
hashseed = bytes(hashsecret.uc)
print(hashseed[:16].hex())
```

`_Py_HashSecret` can be also generated by setting the value of `PYTHONHASHSEED` different from `random` (needs to be an integer `[0; 4294967295]`)

Example:

```sh
sal@LAPTOP-K6PV3EII:~$ PYTHONHASHSEED=0 python3 hash.py
6582741728881602086
```

The output will always be the same

if `PYTHONHASHSEED` is passed, this is generated using this:

```py

seed = int(input("Give me the value of PYTHONHASHSEED: "))

def lcg_urandom(x0, buffer, size):
    if x0 == 0:
        buffer = [0]*size
        
    x = x0
    for index in range(size):
        x = (x * 214013 + 2531011) & 0xFFFFFFFF
        buffer[index] = (x >> 16) & 0xFF


buf = [0]*24
lcg_urandom(seed, buf, 24)

print(bytes(buf))

```

We can verify this using this script:
```py
import siphash # python -m pip install siphash

tohash = input("String to be hashed: ").encode()
pysecret = bytes.fromhex(input("Value of _Py_HashSecret: "))


def hash(tohash, secret):
    return siphash.SipHash_2_4(secret, tohash).hash()


print(hash(tohash, pysecret))
```

Output:
```
String to be hashed: abobus
Value of _Py_HashSecret (generated from PYTHONHASHSEED): 00000000000000000000000000000000
6582741728881602086 # <- the value is the same
```
